.\" Automatically generated by Pandoc 3.6.4
.\"
.TH "BEAR" "1" "Jan 03, 2026" "Bear User Manuals"
.SH NAME
Bear \- a tool to generate compilation database for Clang tooling.
.SH SYNOPSIS
\f[B]bear\f[R] [\f[I]OPTIONS\f[R]] [\[en]]
[\f[I]BUILD_COMMAND\f[R]\&...]
.PP
\f[B]bear intercept\f[R] [\f[I]OPTIONS\f[R]] [\[en]]
\f[I]BUILD_COMMAND\f[R]\&...
.PP
\f[B]bear semantic\f[R] [\f[I]OPTIONS\f[R]]
.SH DESCRIPTION
Bear is a tool that generates a JSON compilation database for Clang
tooling by intercepting command executions during the build process.
The JSON compilation database is used in the Clang project to provide
information about how individual compilation units were processed,
enabling tools like clang\-tidy, clangd, and other Clang\-based analysis
tools to understand your project\[cq]s build configuration.
.PP
Bear operates by intercepting system calls during the build process to
capture compilation commands.
It supports two main interception methods: dynamic library preloading
(on Unix\-like systems) and wrapper executables (cross\-platform).
The captured commands are then filtered through semantic analysis to
identify actual compiler invocations and generate the final compilation
database.
.PP
Bear can operate in three modes:
.IP \[bu] 2
\f[B]Combined mode\f[R] (default): Runs both interception and semantic
analysis in sequence
.IP \[bu] 2
\f[B]Intercept mode\f[R]: Only captures build events to an intermediate
file
.IP \[bu] 2
\f[B]Semantic mode\f[R]: Processes previously captured events to
generate the compilation database
.SS OPTIONS
.TP
\f[B]\-c, \[en]config\f[R] \f[I]FILE\f[R]
Specify a configuration file path.
The configuration file controls output formatting, compiler recognition,
source filtering, and duplicate handling.
.TP
\f[B]\-o, \[en]output\f[R] \f[I]FILE\f[R]
Specify the output file path (default:
\f[CR]compile_commands.json\f[R]).
The output is a JSON compilation database.
.TP
\f[B]\-a, \[en]append\f[R]
Append results to an existing output file instead of overwriting it.
This allows incremental updates to the compilation database.
.TP
\f[B]\-h, \[en]help\f[R]
Print help information.
.TP
\f[B]\-V, \[en]version\f[R]
Print version information.
.SH COMMANDS
Calling bear without commands will execute the combined mode, and will
intercept the compiler calls and generate a compilation database as
output.
.SS bear intercept
Intercepts command execution events during the build process and saves
them to an events file for later processing.
.PP
\f[B]bear intercept\f[R] [\f[I]OPTIONS\f[R]] [\[en]]
\f[I]BUILD_COMMAND\f[R]\&...
.SS bear semantic
Processes previously captured events to generate a compilation database
through semantic analysis.
.PP
\f[B]bear semantic\f[R] [\f[I]OPTIONS\f[R]]
.SH OUTPUT
Bear generates a JSON compilation database conforming to the \c
.UR https://clang.llvm.org/docs/JSONCompilationDatabase.html
Clang JSON Compilation Database
.UE \c
\ specification.
The output is a JSON array of compilation entry objects.
.SS Entry Format
Each compilation database entry contains the following fields:
.TP
\f[B]directory\f[R]
The working directory of the compilation (absolute path)
.TP
\f[B]file\f[R]
The main translation unit source file (absolute path)
.TP
\f[B]arguments\f[R]
The compilation command as an array of strings (preferred format)
.TP
\f[B]command\f[R]
The compilation command as a single shell\-escaped string (alternative
to arguments)
.TP
\f[B]output\f[R]
The output file produced by compilation (optional, absolute path)
.SS Output Formatting
The output format can be controlled through the configuration file:
.IP \[bu] 2
\f[B]Path resolution\f[R]: Paths can be formatted as absolute, relative,
canonical, or as\-is
.IP \[bu] 2
\f[B]Entry format\f[R]: Choose between arguments array (preferred) or
command string
.IP \[bu] 2
\f[B]Field inclusion\f[R]: Control whether the output field is included
.IP \[bu] 2
\f[B]Source filtering\f[R]: Include/exclude files based on directory
rules
.IP \[bu] 2
\f[B]Duplicate filtering\f[R]: Remove duplicate entries based on
configurable field matching
.PP
Bear generates entries where all paths are absolute by default, and uses
the \f[CR]arguments\f[R] field instead of \f[CR]command\f[R] to avoid
shell escaping issues.
.SH CONFIG FILE
Bear uses a YAML configuration file to control its behavior.
The configuration file follows a structured schema with several main
sections.
.SS Configuration Schema
.IP
.EX
schema\f[B]:\f[R] \[dq]4.0\[dq]
intercept\f[B]:\f[R]
  mode\f[B]:\f[R] wrapper
compilers\f[B]:\f[R]
  \f[B]\-\f[R] path\f[B]:\f[R] /usr/bin/cc
    as\f[B]:\f[R] gcc
  \f[B]\-\f[R] path\f[B]:\f[R] /usr/local/bin/gcc
    ignore\f[B]:\f[R] true
sources\f[B]:\f[R]
  only_existing_files\f[B]:\f[R] true
  directories\f[B]:\f[R]
    \f[B]\-\f[R] path\f[B]:\f[R] /project/tests
      action\f[B]:\f[R] exclude
duplicates\f[B]:\f[R]
  match_on\f[B]:\f[R]
    \f[B]\-\f[R] file
    \f[B]\-\f[R] arguments
format\f[B]:\f[R]
  paths\f[B]:\f[R]
    directory\f[B]:\f[R] canonical
    file\f[B]:\f[R] canonical
  entries\f[B]:\f[R]
    use_array_format\f[B]:\f[R] true
    include_output_field\f[B]:\f[R] true
.EE
.PP
This example configuration file: sets the interception mode to
\f[CR]wrapper\f[R], hints the \f[CR]/usr/bin/cc\f[R] to be the main
compiler in this project, which is the GNU compiler, hints to ignore the
\f[CR]/usr/local/bin/gcc\f[R] compilers from the project, disallow to
include files which are not available on the filesystem, instructs to
ignore files from \f[CR]/project/tests\f[R], instructs to detect
duplicates based on the \f[CR]file\f[R] and \f[CR]arguments\f[R] fields
of the output file, instructs to format the output to use canonical path
for the \f[CR]file\f[R] and \f[CR]directory\f[R] fields of the output
file, instructs to use the \f[CR]arguments\f[R] over the
\f[CR]command\f[R] field in the output file, instructs to include the
\f[CR]output\f[R] field in the output file.
.SS Configuration Sections
The configuration file uses schema version \f[CR]4.0\f[R] and has the
following structure:
.SS intercept
Controls the command interception method:
.IP \[bu] 2
\f[B]mode\f[R]: \f[CR]preload\f[R] (Unix) or \f[CR]wrapper\f[R]
(cross\-platform)
.IP \[bu] 2
\f[B]path\f[R]: Path to the preload library or wrapper executable
(depending on the mode)
.SS compilers
Contains hints about what compiler needs to be recognized and what that
compiler is.
.IP \[bu] 2
\f[B]path\f[R]: Path to the compiler executable
.IP \[bu] 2
\f[B]as\f[R]: Compiler type hint for semantic analysis.
Valid values are: \f[CR]gcc\f[R], \f[CR]clang\f[R], \f[CR]flang\f[R],
\f[CR]intel\-fortran\f[R], \f[CR]cray\-fortran\f[R], \f[CR]cuda\f[R].
.IP \[bu] 2
\f[B]ignore\f[R]: Whether to ignore this compiler.
.SS sources
Filtering functionality based on the source file location.
.IP \[bu] 2
\f[B]only_existing_files\f[R]: Filter out non\-existent source files
.IP \[bu] 2
\f[B]directories\f[R]: List of directory\-based inclusion/exclusion
rules
.PP
Directory rules are evaluated in order, with the last matching rule
determining inclusion/exclusion.
Empty directories list means include everything.
.SS duplicates
Filtering functionality based on duplicate detection.
Here you can define which fields of the output file should be used in
the duplicate detection.
.IP \[bu] 2
\f[B]match_on\f[R]: List of fields to use for duplicate detection (file,
arguments, directory, command, output)
.SS format
Output formatting configuration:
.IP \[bu] 2
\f[B]paths.directory\f[R] and \f[B]paths.file\f[R]: How to format paths
of these fields.
The allowed values are:
.RS 2
.IP \[bu] 2
\f[B]as\-is\f[R]: No transformation,
.IP \[bu] 2
\f[B]canonical\f[R]: Resolve to canonical path,
.IP \[bu] 2
\f[B]relative\f[R]: Make relative to directory field,
.IP \[bu] 2
\f[B]absolute\f[R]: Convert to absolute path,
.RE
.IP \[bu] 2
\f[B]entries.use_array_format\f[R]: Use arguments array instead of
command string
.IP \[bu] 2
\f[B]entries.include_output_field\f[R]: Include output field in entries
.SS Default Configuration
If no configuration file is specified, Bear uses built\-in defaults
optimized for most use cases.
.SH ENVIRONMENT
.TP
\f[B]RUST_LOG\f[R]
Controls the logging level for Bear\[cq]s internal operations.
This environment variable is essential for troubleshooting and debugging
Bear\[cq]s behavior.
.RS
.PP
Supported log levels (in order of verbosity):
.IP \[bu] 2
\f[CR]error\f[R] \- Only show critical errors
.IP \[bu] 2
\f[CR]warn\f[R] \- Show warnings and errors
.PD 0
.P
.PD
.IP \[bu] 2
\f[CR]info\f[R] \- Show informational messages, warnings, and errors
.IP \[bu] 2
\f[CR]debug\f[R] \- Show detailed debugging information
.PP
Examples:
.IP
.EX
RUST_LOG=debug bear \-\- make all
RUST_LOG=info bear intercept \-\- cmake \-\-build .
.EE
.RE
.SH EXIT STATUS
Bear returns the exit status of the executed build command when running
in combined or intercept mode.
When the build command succeeds, Bear returns 0.
When the build command fails, Bear returns the same non\-zero exit code.
.PP
In semantic mode, Bear returns 0 on success and a non\-zero exit code if
semantic analysis fails.
.PP
If Bear itself encounters an internal error or crashes, it returns a
non\-zero exit code regardless of the build command\[cq]s status.
.SH TROUBLESHOOTING
The potential problems you can face with are: the build with and without
Bear behaves differently or the output is empty.
.SS Debug Logging
\f[B]Before reporting any issues\f[R], always run Bear with debug
logging enabled:
.IP
.EX
RUST_LOG=debug bear \-\- your\-build\-command
.EE
.PP
This will provide detailed information about Bear\[cq]s internal
operations.
And the debug output is essential for diagnosing problems and \f[B]must
be included\f[R] in any bug reports.
.SS Common Issues
The most common cause for empty outputs is that the build command did
not execute any commands.
The reason for that could be, because incremental builds not running the
compilers if everything is up\-to\-date.
Remember, Bear does not understand the build file (eg.: makefile), but
intercepts the executed commands.
.PP
The other common cause for empty output is that the build has a
\[lq]configure\[rq] step, which captures the compiler to build the
project.
In case of Bear is using the \f[I]wrapper\f[R] mode, it needs to run the
configure step with Bear too (and discard that output), before run the
build with Bear.
.SS Getting Help
There could be many reasons for any of these failures.
When seeking help:
.IP "1." 3
\f[B]Always include debug logs\f[R] (\f[CR]RUST_LOG=debug\f[R]) in your
report
.IP "2." 3
Consult the project wiki page for known problems
.IP "3." 3
Search existing issues before opening a new bug report
.IP "4." 3
Follow the bug report template, provide the requested fields
.SH COPYRIGHT
Copyright (C) 2012\-2026 by L치szl칩 Nagy \c
.UR https://github.com/rizsotto/Bear
.UE \c
.SH AUTHORS
L치szl칩 Nagy.
